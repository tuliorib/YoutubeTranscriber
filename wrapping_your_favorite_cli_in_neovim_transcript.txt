today we're want to be talking about wrapping your favorite command line interface in neovim and we're going to do this by building essentially plugins in neovim 0.102 now what are we talking about here what what do we mean by wrapping your favorite command line tools and and plugins we're talking about having Neo them farm out work to some of the command line tools you may be familiar with like curl or get or distant huh huh and in this talk we're going to actually run through four examples we're going to run through getting the temperature for a city you specify and printing that out in neov we're going to talk about showing top so getting the active list of processes displayed in a floating window in neovim then we're going to get to a pretty fun one which is we're going to use a headless version of Firefox to render websites and display it in NE them and then last we'll get into more of a an interactive how you build a UI uh in NE ofm to interact with a tool called sapling a source Control Management tool like get and so we'll run through all four of these but before we dive into these specific examples we're going to run through and it's get on the same page with regards to what is a commandline interface if we quote Wikipedia my favorite Source it me it's basically a means to interact with a computer program typically by inputting lines of text which apparently they're called command lines I actually didn't know that that that was the name yeah you send a program some lines of text and it does something maybe it tells you something back maybe it doesn't but this is how you would communicate with programs and from my perspective there really three kinds of command interfaces the first you're most likely familiar with which are command oriented or single action single purpose they do one thing with each execution each time you run the program it does one thing and then it finishes so you think of curl in this way where you want to access a web page download something from the web you can think of get this way when you are retrieving a manipulating uh parts of get repositories and Docker as well right if you want to run some commands run some containers manage some containers single command to do this now alongside the command oriented you also have stream oriented which is doing many things over standard IO Network IO but it's more than one thing and usually you're you're sending commands getting a response sending another command getting a response usually it's a request response model so an example of this would be rust analizer which is a language server that accepts requests over standard in and responds via Json over standard out uh you have Firefox which you can actually remote control via a Marinette uh server which runs over TCP and even tools like rip grip if you didn't know actually support streaming results uh over standard out as Json individual Json lines they have a Json line protocol the last form which are also very familiar with you use neov them is interactive so it's like stream oriented you do many things but they typically provide their own user interface uh and you know accept keyboard input a little bit more and so some common ones are things like top available on pretty much all of your computer systems bash zsh your shell it's not listed here neovim is a pretty big one here lazy gets another tool all of these are more interactive and so we're actually going to give examples that run through each of these different kinds um starting with the command oriented uh then we'll jump over actually to interactive then stream oriented and then kind of have a wrap up a concluding example now before I go any further did you know it's pretty easy to actually run programs in neovim without any Lua whatsoever and a couple of these ways are you can actually run programs connected to a pipe and we do this with the bang command and you give it it doesn't run in a terminal which has its own nuances but you essentially give it a command and it outputs it into a specialized space with a neov them I'll give you an example here so we're going to use Curl to access a weather site using uh a specific uh format of the curl uh website to get uh just ansy character responses so I'm going to use a specialized ter terminal this is Kitty here just for the examples we have so in this case if I do bang I do curl d s to suppress some of the curl output I access this weather site with uh a question mark T and actually I'll go and put in let's say Boston here um you actually get back uh some weather now it's a little bit garbled here so actually I will jump over I will actually use uh this terminal instead to do the same same thing so curl d s with the weather site I'll do Boston again with a t and boom you've got weather right so it tells me the next three days of weather uh and that was pretty easy to do and it's dropped into NE ofm um but did you know that that's right you can actually use the same command you prefix it with a percent sign and it'll actually place the output in your current buffer so if I jump over uh and go back to adding a percent sign in front of my command uh it actually puts it into this buffer you can say I'm in a buffer I can obviously select it all I could I can delete multiple lines here um but yeah pretty neat you can actually uh use this to run a command and put contents in a buffer so that's just kind of some neat little little trivia for you if you weren't familiar um but beyond this how we're going to make something a little bit more plug-in oriented for running our programs well in neovim 0.9 or earlier there are so many different ways to do this I mean so many different ways and I listed a handful of them here you've got of course bang and percent bang um you have some other Vim commands you can run you can run terminal to run some command and a non-interactive terminal this is bit different than the bang and percent bang it's actually in a terminal and not in a pipe you can call out to the system command which was the Vim Vim way of doing things you can use term open and then you have Lua forms you can call L IO you can access the lib UV uh through like the love uh bindings I think which is uh v.v. spawn you can access all the Vim script commands through vm. FN vm. function and then you can use invm open term so many different things and some of them were async some of them weren't async which ones you need to use they all had different apis and interface cases it was pretty complex thankfully in neovim 0.10 we had the introduction of vm. system hooray hooray this is huge because it does both async and synchronous execution of programs gives you a nice wrapped up form to get standard out standard error feed standard in to the programs um this is just so good and it solves so many of our problems um we'll also demonstrate a little bit of the Vim function term open just for our top example which lets you essentially run something in a new terminal and embed it in a window um we're not going to really touch on the Vim API and themm open term very likely you're never going to use this it really lets you proxy and provide a terminal without running anything so you can feed in something directly in to be standard out and and whatnot and it's I've used it for proing uh processes like with distant D in them but really going to focus on the first two and really vimn system is going to do the heavy lifting for all these which is great so now we can focus on some of those higher level fun examples instead of doing a lot the plumbing used have to do with the older apis and so just so you're familiar with how vm. system works it like I said can be run asynchronously or synchronously the in synchronous version you essentially will give it as a third argument uh a function that acts as the on exit when this process exits here's an object that contains the exit code a signal standard out standard error if you run if you want to run it sign synchronously you don't provide this function and instead you will just at some point call wait you can give it a timeout I think it by default is 5 Seconds and it essentially Returns the same object you'd have in your call back and so you can use this to run a program wait for the results and do something with them and that's really how we're going to implement all of our examples minus the top is to essentially run a program with VI note system get some result results and do something with them now it's time for examples and the first one to do is wrapping uh curl to provide a temperature plugin and this is essentially going to use Curl to talk to that weather website I I demonstrated earlier and you can actually give it a query parameter that's that question mark format to say hey I want Json and so we're essentially going to use the system command to call out with curl say curl go access this website give me back Json we're going to decode it using the json. decode function and essentially use it to print out ideally what the temperature is in some City Boston Austin any of these cities right and so it looks like if I jump back to our examples um if I run the temperature command and I give it a location location I'll give it Austin this time uh you'll see Hey look it's currently 84Â° fah in Austin pretty hot and that's it that is what our plugin does now now uh if I uh kind of run through some of the things we do here um one of the things I always recommend to do when you're building a plugin around some command line tool is to write a health uh checking uh feature and that involves in our case we want to make sure that curl exists that we have the right version that we can access the temperature website and to do that neoven provides well a uh way to have your plugins provide a health interface and it works by basically just calling out uh this Vim Health start and then if everything's good you can do okay and something's bad you do error that's it and it looks like if I if I do a check Health here and I do the temperature um you can see that we actually get a nice report we found curl it was a version that was acceptable and we can access the website great uh and so what this looks like in terms of programmatically doing this is we could use something like the executable function to see if an executable exists in your path and is executable uh from there we can check if the version is correct we do this actually by doing a call to curl and do das Das version obviously this can be different from each of your command line programs typically they're going have a D- version or Dash capital V or something we actually Waits this is a synchronous call you actually need to do things synchronously in the health checks they don't support asynchronously calling those Health functions and Vim actually provides semantic version parsing which is vm. version. parse it's actually smart enough to check and see if hey something like curl is the first word and then it looks like the second word for a version string and we can use that to see if it's like the major version for example is what we expect lastly in our case for this weather example this temperature example we call out we see if curl returns a nonzero exit code which in this case would mean if you got nonzero means you provide some issue accessing curl or getting the information you wanted so we put those three together and we essentially get what you'll see in our health file here which is where we do exactly what I what I was talking about we see if curl exists we get the version and then from the version we check and see if uh it's available in the right version and then from there we access the website and see if the website's accessible pretty easy stuff and uh really from there let's dive into the code for the weather and it's not much more than what we showed in the health example which is uh we essentially have a way to encode a URL in this case for curl and then really we fetch some information right and fetching it means we curl out to get some Json which as long as we get a zerox code we assume we got the Json correctly and then we just parse it using this uh decode Json function of neov and we have data in this case we know that data essentially has a a field called current condition and from there it has a temperature F and for printing we essentially get that Json blob as a Lu table access the first element and get the temperature and print it out and that's it that is our very first example is we read some Json from curl called curl to get the Json itself printed it out pretty straightforward now the next example we've got is wrapping top and this is actually going to be even easier than curl because because we're going to take advantage of this function called open term we're going to create a floating window so we can have it be nice and pretty but essentially open term takes a hold of whatever buffer is in uh your current window takes over it and runs the program in a terminal and in our case we're going to configure it to exit as soon as the program exits and so this looks like uh if I uh get out of that Health option I can just run top and you'll see I have an Interactive top as a floating window in neovim if I hit Escape or rather a q uh I quit and exit the window um if I had run top and uh like control seed it would also exit the program and exit the window so that's pretty darn simple and it looks exactly what we are hoping it look like where you have a floating window here with uh the top command running now if we look at the code for this plugin it's also pretty simple uh in fact uh it can fit in uh yeah pretty much uh one Windows worth uh of my screen and most of the work is actually just setting up the floating window so we create a buffer here we create a floating window that takes up about 80% of our neovim editor session and this is it this is all we do we use term open we run top and when the program exits we close our window that's it super easy so if you something interactive and you want to wrap your interactive command line program like a lazy G or something you can literally just run term open do stuff in it and when you're done when the program exits just close the window it's that easy now this third example is going to be our most complex and it's because we have to do a lot of extra work to communicate with the process so here's what we're going to do we want to run Firefox we want to run it headless we don't have a bunch of Firefox Windows popping up all over our computer while we're trying to use it and we're going to run it with a thing called marionette enabled and marionette it's a server that Firefox is bundled with it basically let you drive Firefox remotely it's typically used for uh Engineers that want to do testing with their browsers they want to remote control their browser different things there's a standard uh for web driver um I think they start with selenium they like a standard got created which a lot of browsers have implemented that basically let you talk to these browsers over TCP and support certain commands you can run like navigating to website um taking a screenshot that kind of stuff and so that's exactly what we're going to do is we're going to run a headless Firefox start this marionet server connect to it over TCP tell it to go to a certain web page tell it to take a screenshot download the screenshot uh save it to a file and then use a plugin called image. invm to display that screenshot which will basically look like something like this where hey we we load a website and there it is it looks like we actually displayed it in new of them right um that's what we're going to do to do this specific example I'm going to bring over uh Kitty um technically you're seeing images displayed in westerm and I try to get this to work with West term but there's some nuances where Kitty just is the one that actually works properly so we're going to use Kitty I'm going to use this web view it's the name of the command I wrote here and I'm going to go to uh we will go to neovim comp. live and what this should do and sometimes it's got quirks that I have to rerun the command um but what it should do is it will uh navigate to the website and then bring it up that's what it just did it brought up uh the neocomp website and you can actually scroll through and we got a great keynote here and we got fantastic speakers like so many good speakers in this list um and so that's it that's all we did uh and it was pretty complex to do that in terms of some of the plumbing to talk to Marinette but otherwise the process itself is pretty straightforward spy Firefox connect over TCP to Marinette talk to Marinette to get some screenshot and navigate to websites and get more screenshots save the screenshots and load them with image in them so if we look at the code uh this one uh I'm not going to go through everything for this one because it is actually a bit more complex in terms of how you talk to to all these processes but nutshell we have logic that says Hey I want to spawn Firefox we check if Firefox exists on our path and then we can start it and we start it with certain commands so we use our vm. system like we normally would we're running an asynchronous this time so we're not blocking we're not waiting for the process to exit running it headless we're making a new instance and we're using marionette um and then from there we actually have a uh a marionette uh connector here and so this is actually does the TCP so we use TCP we connect to marionette we start reading uh to get the data from Marinette so whenever you send data you get something back like a acknowledgement or something else and you do a little bit of fangling to aggregate the data because it's a it's TCP stream it's a raw chunk of data you want to wait till you get proper messages uh received and then when we get messages we basically Echo them out right so we have an interface to send this data following maret's format for how it wants things over TCP and then parsing the data back and at the end we basically glue these things together where we start Firefox uh we connect our driver to be able to send information and then if we say want to display the screen like we did we essentially tell it to take a screenshot and then display it with our viewer and the teching screenshot essentially does what we've already discussed where it uh uses our driver to take a screenshot we get a base 64 bit of data which we save into a screenshot file and then we view it using that image. invm plugin which mostly just comes down to creating that floating window again and adding some key bindings to exit out more easily and then really just getting the the file the image file and displaying it had a little bit do a little bit tricky to support scrolling but this is a demo and that's it right um if you aren't familiar by the way uh being able to have these commands is pretty easy like the web view the top the temperature you just create a new user command and then for each of those we're essentially doing something like calling some of our API and this one is a little bit more complex to display something but otherwise they're pretty straightforward now the last example we have is something called sapling if you're not familiar with sapling it's basically another source control manager it actually interfaces with get uh it's based on uh meta's work with Mercurial that they then forked and they since released open source a couple of years ago go and I actually wrote uh my presentation repository using saplings so um if I jump over to a new uh tab here in my terminal uh you can see that I've actually got sapling and I actually have sapling set up with a couple of dummy commits here um so what we're going to do with this one is I want to have a buffer that ACC as a UI for sapling and this buffer will essentially communicate and it'll run a oneoff sapling commands one of which is the Smart log which I just did here this is technically the smart log you can you can type out the the whole thing as smart log and it gives you a different format we'll use this to provide certain temp templating essentially it just gives you the list of your commands like if you did get log and we'll use uh goto to actually navigate between the commits um now providing a UI for your commands essentially means having a buffer where you take key maps different different key mappings and do things that maybe uh React to what people press in the buffer where their cursor is located in the buffer display different things in the buffer and so for our use case we're going to do something fairly simple we're going to display that smart log in a buffer and if I have my cursor over a line with one of these hashes one of these commit hashes like the 165 and I hit enter it'll jump to that hash right that's all we're going to have it do and then it'll just refresh itself pretty straightforward and so if I go back to uh my terminal here and I type in sapling um I actually get this little buffer on the side it has my three commits and remember these three commits are exactly what I showed here um and if I uh just explain sapling the at symbol is what commit you're on so in this case that's the commit I'm on uh if I want to change different commits I want to go back to uh what's on Main right now I just go over here and I hit enter and now you'll notice that the Amper stand is here instead of one of the these two and I'll actually bring over the little user interface I have which is right here so this is what it looks like I'm right here and if I go back I hit enter and I jump back and I bring this forward you'll see in a second this will refresh and it will show that I've actually jumped uh from this main to the world here so we just provided a a little user interface to show us where we are in this commit tree and then hit enter just to jump to the uh the commit right there we go again it just jumped to this uh to this commit uh and that's it that's what we did uh for um the sapling uh plugin uh and now what this looks like if we jump to sapling it's also pretty straightforward we essentially have one Lua function wrapping each of the commands we want to do and most of the work is just hey I want to run the go-to command with a certain commit hash and when it exits um I want to you know report an error if I want to be async otherwise I can I can block and wait uh um and then for smart log I want to actually get the smart log out now we actually provide a template here to guarantee it's always consistent doesn't have any of the uh color codings to throw things off in your in your buffer essentially we just have it say run smart log and give me back the the standard out right and then this other one run goto and I don't even care if the standard out is as long as it doesn't uh error uh and so we combine these two where we hey look we are going to create another uh floating uh window um further down and we're going to bind a couple of commands and this is really the meat of it right so we we bind a couple of buffer local commands uh key bindings and so we have R to refresh uh and then we have hitting enter which will basically get the text at the current line figure out the commit hash from that current line and if we have a commit hash uh update saying we're going to go to that commit and then essentially use our function from before to go to that commit that's all we do and also the logic is just you know making it pretty like getting whatever the text is at the current line um refreshing the buffer to get more text which is what we call the smart log function essentially what we've done is we've have a buffer where we populate with some text from our program and we hit certain key mappings it will run more programs and update the text in the buffer based on the responses to those programs and that's it that's how you can make a some pretty nice user interfaces wrapping some of your favorite commands is you make a buffer you populate with some of the put from your commands have a couple key mappings that will do things and run other commands as a result you can Channel these together to do some really interesting uh stuff and so with that I'm going to just wrap up here by giving some some shoutouts some credits um you've seen four examples of how to wrap some interesting programs and use them in neov uh and I want to thank Andre here third on GitHub who actually wrote image. invm that I used and helped me to diagnose some of the issues and getting the screenshot working in the scrolling to work uh correctly and so if you'd like to reach out to know more ask some questions or just chat about NE them or some other things got different uh content information here I also put some of these videos on YouTube every couple of years so you're welcome to check out any of those um but I hope this get you pretty excited about what you can do in neov them and stay tuned if we introduce actual native image support uh into neovim itself without needing uh plugins we can do even fancier things um uh like having video feeds come in where you could actually have a video playing and some other neat stuff uh but thanks and enjoy the rest of neovim comp 2024