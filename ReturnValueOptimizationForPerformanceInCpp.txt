a lot of interesting stuff happens in the hallway it happens uh you you know you get to walk out of of a session and there's a collective experience that you just went through and so there will be a hallway conversation that Springs up discussing the [Music] material can you rvo how many people here have heard about return value optimization before please raise your hand okay that's a lot of the room don't worry if you don't know it you learn about it today and how many people here would consider themselves to be experts at rvo please raise your hand okay no one in the room but that will change after this stock so hi my name is Michelle I'm a software engineer at Bloomberg where I write code for the order management platform that Traders use to buy and sell Securities on the exchange billions of orders flow through our system on a day-to-day basis and every second counts so performance is super important I got my degree in computer science from Berkeley where I was a teaching assistant I am a member of the the C++ guild at Bloomberg and I speak five languages and for this particular audience it's important to clarify that these are five non-programming languages I speak many more programming ones but honestly it's possible that no one cares and that's fine as long as you care about return value optimization AKA rvo So today we're going to cover what return value optimization is the anti patters that prevent it from happening and we'll also cover using rvo for performance gains and I will take questions at the end and we're going to have a little bit of fun today because I've actually brought stress balls with me from London and they have these really cute messages on them and I will be having questions during the talk so if you answer correctly I will give you a stress ball and I'll work through the logistics a bit later but pay attention because you get these really nice things so return value optimization first made its way into the Zork compiler in 1988 so for those of you that don't know the Zork compiler was the first ever C++ compiler to ship for Windows and in 1989 it made its way into the seafront compiler and in 1997 in the London meeting it was added into the C++ standard so if rvo has been around for a while why are we talking about it now well at Bloomberg I have seen a number of cases where people have forgotten to use rvo in their PRS and they have been reminded about it later or even worse they haven't been reminded about it at all and sometimes people try to be smarter than their compilers and they try using things like uh pointers references and a bunch of other things to try and get better performance improvements when really it's just rbo that you need and this is not a problem local to Bloomberg because even outside in the broader C++ world this pattern repeats itself people forget that rvo exists and so what happens if I forget about rvo it's fine right it's completely fine well no it's not because you lose out on potential performance gains and you also lose out on simpler cleaner code so what really is return value optimization if you look into the C++ standard and don't worry if you can't read the text you'd be surprised to know that rvo actually isn't there and this is absolutely fine because rvo is a form of something known as copy elision and that is defined in the standard and in this section there is a snippet that defines when copy elision is applied particularly when you have a return statement and I could stand here and read that statement out it might be too tiny for you to read but it says in a return statement in a function where the class return type blah blah blah blah blah blah blah that's what it says at least that's what I read it as when I first tried to really understand what return value optimization was and while this is a very useful specification like hob sat says the standard isn't a tutorial so so instead I went to my best friend chat GPT and asked it what return value optimization was and it told me that it is a compiler optimization that eliminates the creation of temporary objects by directly constructing the return value in the memory location of the colum and what does that really mean well if I have a piece of code like this where on line two I create my object a so I'm initializing it using my object three and then on line three I return it and on line eight what I'm doing is I have this local variable E1 that is being initialized from the return value of example one with return value optimization what happens is instead of constructing my object three in the space allocated for local variable a on line 2 we construct it directly in the space allocated for local variable E1 so just to see a different perspective of what return value optimization is this is actually the Assembly of the piece of code you just saw but on your left uh the case where turn value optimization is off and on your right where we have the case where return value optimization is turned on there are differences you don't need to understand assembly to understand this because really the most important thing here is that on line four we have the RSP which is the stack pointer moving down by 32 bytes in the case where return value optimization is turned off but in the case where it is turned on we move the stack pointer down by only 16 bytes so we are using less space on our stack frame when we have the optimization the other interesting thing here is that in the case where we have rvo off we have this whole extra function call happening which we don't even have in the rvo on case and maybe I don't need to say this but the number of assembly instructions in the case where rbo is off is way more than in the case when it is on and yet another visualization but this is your stack frame when return value optimization is turned off what we do is we would construct my object 3 in the space allocated for the local variable a but when we have the optimization on we would construct it in the space allocated for local variable E1 and if we were to see these two diagrams side by side we'd notice that inde we are using less space on that stack frame for example one so return value optimization comes in two forms there is the named return value optimization which is n rvo and the unnamed one we have an example example one and in this example we're showing nvo because what we're doing here is we initialize my object a and then we return this named variable since we're returning an L value we which is a named variable in this case we call this named return value optimization and example two shows us unnamed return value optimization and what we really are doing here is we are returning an unnamed variable we're returning a PR value directly and you might be wondering why do I need to know this this is just terminology well the difference is actually really important because it kind of defines how your compiler or whether your compiler provides the support So compilers are actually allowed to perform unnamed return value optimization since C++ 98 but they have to perform this optimization since C++ 17 and this is only for the unnamed version of return value optimization so in a way unnamed return value optimization is guaranteed for you there is no way to turn it off from C++ 17 onwards but the named return value optimization on the other hand the support for that is optional but it is recommended we can do something a little evil we can actually turn off named return value optimization and we can't do this for unnamed return value optimization again in C++ 17 onwards because remember that is guaranteed and also you might be wondering hey if this whole nvo and urv thing sometimes is optional does this mean that my compiler even supports it well don't worry uh all major compilers like msvc GCC and clang do support the optimizations but again we can turn the optimization off in GCC and Clank using this no Allied Constructor flag and we can do something very similar in msvc but we can't actually use this flag because msvc disables nvo by default but it can be enabled using the zcn rvo option the O2 optimization or the permissive options so let's play around with a tiny example so I have a class my object and it has a Constructor which prints calling OG Constructor and for those of you that don't know what OG means it just means original according to my sister yes that generation and we also have a copy Constructor over here which prints out the line calling copy Constructor we are running these examples with x86 64 GCC 13.2 as a compiler and we are using C++ 17 with that no Allied Constructors flag which turns off named return value optimization and C++ 23 produces the same results for all the examples you will see today and of course just to mention uh this slide over here doesn't have the copy assignment operator and the destructor shown but just assume that it is present okay so we have these examples and example zero just returns my object 3 and if we were to print out what happens we just have the call to the vinilla Constructor because remember the flag no Allied Constructors can't actually disable unnamed return value optimization but if we were to print out examples one's result we would have an extra calling copy Constructor line printed out and the number of copies printed out actually depends on the version of C++ so you might have more number of copies in C++ 11 for example but the important question here is what are those copies so the first possible copy that you can have is when you copy my object 3 from wherever it was constructed to the space allocated for local variable a your like second potential copy is when you copy initialize the return value from a that is you copy the value from the local variable a into the return value slot and your final potential copy is when you copy the value from the return value slot into the space allocated for local variable E1 and if we remove the no Allied Constructor flag we would have both unnamed and named return value optimization and so there is no call to your copy Constructor but we have forgotten something and ladies and gentlemen this is your chance to win a stress ball so do you know what we' forgotten anyone you can yell it out what was that anti fatens we'll come to that we will get to that that's true but there's something here that we've forgotten so we had our copy Constructor and the rule of three oh that's a raised hand ass oper assignment operator we do have that remember we had rule of three and we mentioned it would be there that's a good guess move Constructor move Constructor congratulations you have won yourself a stress ball again I'm a software engineer I can't throw things uh but here you go oh I can throw okay never mind sorry I tried my best but that's stressful is for you cool so yeah we have forgotten our move Constructor because in C++ 11 onwards there's something known as move semantics and move semantics essentially just help you avoid that copy and using an R value reference it is usually seen to be more performant than calling the copy Constructor so we can add the move Constructor into that example we had and assume the rule of five applies but in all the examples we saw the same thing happens except instead of calling the copy Constructor we call the move Constructor and so the question here now is does rbo even really matter if we have a move and I have an example over here where I have a for Loop that runs 100,000 times and in this for loop I am just initializing a and a is just the return value of example one and in this example I am just constructing a and then returning it classic potential nrb so I have compiled my code with C++ 17 and in one case I have the no Allied Constructor flag and in the other case I do not have this flag so what I did was I actually just used the terminal function time to time this code so very simple very basic and the question was do we have a performance Improvement I won't give you a stressful for this because it's probably too easy to answer but the answer is yes we actually did see a performance Improvement and it was very consistent and if I were to use this Nifty little speed up function to calculate the speed up I would get around 26% but this number isn't important because the number that you get the percentage is just going to depend on what you do in your actual use case it can vary significantly the important thing here is the Big Green yes return value optimization matters so when does return value optimization not work so one when we are evil and we disable it like we did earlier the other case is when the object construction happens outside the scope of the current function so what we're doing in this example is we are initializing my object a in the global scope and in example one we are returning it because we constructed a outside of the scope of example one there is no return value optimization being applied because your compiler doesn't know that when I'm constructing my object 3 it needs to be returned in example one at that point the other case where return value optimization is not applied is when the return type is not the same as what's being returned so over here I have this class called my object child which inherits from the class my object and I have another function called inheritance fails rvo which Returns the type my object even though it's really returning my object child and my object child can use the same amount of bytes that my object does it does not matter return value optimization still won't be applied the types need to match we have yet another case where return value optimization won't apply and that's when there are multiple return statements returning different objects and this applies to only NRV so we have an if Branch over here and in one case we return X1 and in the other case return X2 at compile time your compiler does not know which branch is going to hit because of that random function over there literally R and D random um and because of that there is no optimization applied the other case where we don't have this optimization is when you're returning a complex expression so if it is something that is not a vanilla L value or PR value then you don't have return vality optimization as rule of thumb yeah that's all I'm going to say for now so this applies to only an rvo and the other case is for not guaranteed rvo you either a move or copy Constructor is sufficient so if we go into our example and we delete the copy Constructor as well as the move Constructor and in example one if we initialize a and then return it this code isn't going to compile but if we were to return a PR value Instead This code compiles perfectly and you have unnamed return value optimization isn't that great okay we're going to have time now for stress balls we have questions and what you need to do is answer whether return value optimization is applied in the example I will show you and the logistics for this is that when I show you the example you have a choice you can raise your hand if you think that there is return value optimization in the example and you can keep it lowered if you think there isn't and I will throw a stress ball at you potentially and this is a random algorithm depending on my throwing skills and is someone keeping their hand raised for everything sorry what was that chances of that is true you can go brute force and keep your hand raised for everything I might pick on you to answer things and explain your answers potentially but yeah that's how it's going to work I will throw a stress ball at you but if you've answered incorrectly you have to give the stress ball to someone who has answered correctly y don't don't be sad it's good it's fair okay so the setup for each of these examples is going to be as follows we have my object e0 that's being initialized from each of the examples you're going to see and we have the move and copy Constructors we had previously with the rule of five everything is perfect first example we have my object a and we change one of the member variables of a and then finally we return it do we have return value optimization you can raise your hand if you think there is return value optimization and keep it lowered if you think there isn't okay the answer is actually I'm going to throw it at someone I'm going to throw it at I think who answered first and I hope I have really good aim oh my God I'm impressed you are right so there is return value optimization congrats on your newly owned stress ball and just to explain what's happening here when we have that no Allied Constructor flag we have that extra calling move Constructor printed out because they're turning off named return value optimization and when we don't have that flag the optimization is applied which is why there's only calling OG Constructor the vanilla Constructor that's printed out next example we have Auto instead of my object do we have return value optimization raise your hand if you think there is and keep it lowered if you think there isn't okay most people have raised their hands and I'm going to throw it to who I think answered first I have really really good aim is really good uh yeah so yeah return value optimization is applied in this case Auto doesn't change anything okay are we ready for the next example yeah so the next example is returning stood move a do we have return value optimization raise your hand if you think there is and keep it lowered if you think there isn't okay we have 1/4 of the room maybe maybe a little under that's raising their hands so the fun part here no you can't low your hand now keep it the fun part here is that we don't have return value optimization and I'm going to throw this some well I can't actually tell who answered first because okay this is going to be a random throw yes there is no return value optimization because we have a stood move this is the complex expression that's not a vanilla L value or PR value and this is something I've seen a lot in code bases so please do not try to stood move things if they don't need to be stood mov because again without that stood move we would have only the vanilla Constructor being called but now we have the move Constructor as well yeah Clank does we'll actually get to the tooling PA that's a very good point do you want to stress ball is that why you on okay next example what we have here is we are constructing my object X1 and my object X2 and then we have an if branch and in one case we return X1 and the other X2 do we have return value optimization please raise your hand if you think there is okay we have a few hands raised so unfortunately the compiler does not know that they're it's going to return X1 or X2 at compile time because of the random function right so we don't have return value optimization okay I'm going to throw this stress ball randomly nicely no people were harmed during this presentation I will throw nicely yes yes I'll come it's very s question so the question was the compiler basically you don't understand why the compiler doesn't know which object is being returned yeah yeah exactly it's the exact same amount of bites in either of the branches right so it's a good question why doesn't a compiler know and that is a good question for people who write these compilers I actually have the same question and I think maybe the compilers need to be improved potentially to know in the case where the return type is literally using the same amount of bytes just you know make the optimization but there are things you can do to just improve your own code so that you have the optimization and we'll cover that great question no stress ball yet because remember questions at the end get stress balls question yes good question we'll get to that at the end because it requires has a bit of explanation but yeah good questions okay next question for stress ball we have a very similar example except we have const my object do we have return value optimization so the return type is Con my object but we are returning my object so raise your hand if you think there is return value optimization and keep it lowered if not okay a good amount of the room is raising their hands so I didn't see who raised your hand first so this is going to be a little random I won't hit anyone did you answer correctly yes good good good all right so yeah there is return value optimization in this case so CV qualifiers don't actually affect whether you have return value optimization or not so it doesn't matter if you have const over there because you still have the optimization that was simple enough what about this case where we are returning aary so we return if a is greater than 50 we return X1 else we return X2 please raise your hand if you think there is return value optimization okay we have one hand imagine if you were right you get the stress for but nice try uh there is no return value optimization here and what's terrible about this is we have three calls to OG Constructor not two we have X1 X2 and then the third one's present because we returning that turnery and we also are calling the copy Constructor even though we've defined the move Constructor right so just to prove my point I moved the turnery outside of the return and now we just have those two OG Constructor calls so what you can do to improve this code is you can actually stood move move it and if you stood move it you don't have that extra OG Constructor call and you don't have that extra copy Constructor call but what is even better in my personal opinion is doing something like this so what we're doing here is we're using unnamed return value optimization so it is still aary but what we're doing is we're replacing X1 and X2 from the previous example with my object three and my object five and we don't need this to move here because we have unnamed return value optimization and we have just one call to the OG Constructor and I know some people here are glaring at me because they probably hate Turner so you could also do something like this just write out your if branch and then return my object three else return my object 8 so this also uses unnamed return value optimization and people might be saying oh this is terrible I don't know what's happening here it's better to use a variable name and I've actually gotten this comment on one of my PRS saying you should not use magic variables I'm sorry if my colleagues are watching this uh but yeah I see that perspective but I think if you comment your code and just name your class as well it's better to do something like this than what we saw previously next example do we have return value optimization here so we are constructing my object X1 and then we have an if Branch where we return X1 in both cases please raise your hand if you think there is return value optimization okay most of the room has their hands raised again this is going to be a random function throwing stress nicely nicely nicely whoops nice catch okay there is return value optimization here right because the compiler knows what it's return what about here when we move X1 inside of the if branch do we have return value optimization so we have two calls to X1 please raise your hand if so two calls to my object three please raise your hand if you think there is return value optimization okay there is no return value optimization here people are sad I'm sorry but the reason for this is because your compiler doesn't know which branch it's going into and so it just doesn't get the optimization compilers are not completely smart yeah true but it is what it is what if I did this so it's very similar to the previous example so I'm going to go back a bit just to show you what changed but in this example what we have is we have X1 in the first case and x2 in the other case but what we've really changed is our compiler so in the previous example we had GCC but now we have clang do we have return value optimization now please raise your hand if you think there is return value optimization yes there is return value optimization and I will throw the stress ball and I think people who G throw by me yes so we have return value optimization here so GCC could have potentially become smarter and done something like this but it just isn't smart enough that's fine we can work around it and in all the other examples you see today King and GCC like behave the exact same way this is just one of the exceptions that we will see um so in general they work the same way but this is a good exception to just know about okay this is slightly out of scope because it is a throw and not a return so obviously return value optimization is does not apply because it's not a return it's a throw but do we have an extra call to the move Constructor or copy Constructor when we throw something instead of returning it so please raise your hand if you think there is a call to the move Constructor and keep it lowered if you think there isn't okay so there isn't a call soorry there is a call to the move Constructor so people who raise their hands it means you said there was a call to the move Constructor so I'm going to give it to the person yes yes now you can catch I can throw okay I can't throw but you caught it but yeah there is a whole extra move Constructor call when you throw things what about now when in instead of just throwing it I try to throw it and then I catch what I've thrown with a reference and then I return that value when I return e is there return value optimization no okay yall are right there is no return value optimization and I don't know who said no oh okay then in that case it's going to be a random press ball I'll give it to someone in the front maybe okay never mind I'm glad that cup had a lid on it cool so the reason I'm showing you this example is because in production I have seen cases where people have code where they try something and then they catch it in a particular function and then in the next so they rethrow in that catch and then in the next function which has called that function the previous function it does the same thing again and again so throwing doesn't really help with performance if you throw multiple times so just be mindful of this example and just FYI removing this reference near my object and per e will still mean that there is no rvo next example so what we're doing here is we have a parameter for the function and we then pass in my object 3 as the parameter and then we finally return that variable to returning a do we have return value optimization okay raise your hand if you think there is return value optimization keep it lowered if not okay we have 1/4 of the room raising their hands so there is no return value optimization here I love how when I say there isn't people just drop their hands that's good but it's okay to be wrong it's fine but yeah um we don't have return value optimization here because my object three is in a way constructed outside of the scope of example seven although you can argue it's kind of in scope but just be mindful of this example where we don't have return value optimization and yes I will throw a stress ball please look in case it hits you but good catch question the copy Constructor and the move Constructor you mean the whole function what do you mean this example right uh okay so the question was is it possible the the compiler optimizes the whole function away as in it wouldn't call the function or no it will still call example 7 it wouldn't optimize it away at least for GCC and sorry what was that oh okay I will okay yeah so the answer was because we have the ozero optimization then we won't have that optimizing the whole function away basically yeah thank you for answering that and actually I will give you a stress ball [Music] somehow cool great prise he's already Bloomberg okay next example so we have I think four more examples all right uh so this example we have class my object 2 and we just have a vanilla Constructor move Constructor and copy Constructor we have another class my object and this class has a member variable B of type my object two and it has the same move copy and vanilla con instructors as we saw previously do we have return value optimization wow just hand raised okay yeah do we have return value optimization if what we're doing is we return x1b where the type of X1 is the type my object but x1b is of type my object to please raise your hand if you think there is return value optimization okay we have one hand two hands so there is no return value optimization in this case because at the time of x1's initialization the compiler does just doesn't construct um that member variable in the return value thought it just thinks about X1 only so I will throw the stress ball again randomly um yep what could we do to improve this code so what we could do is actually have a function that constructs B and then returns it and this does have a catch of course if you are calling get B multiple times that's not good because that means you're calling your OG Constructor or your vanilla Constructor multiple times but if you are only going to call this once and then pass your return value around maybe something like this actually is better and so if we did do x1. getb we would have return value optimization in this case so you've optimize your code what about this where we return a plus equals 1 do we have return value optimization we have one hand raised two hands raised few hands raised so we do not have the optimization because remember this is not a vanilla L value or PR value it's a complex expression I'm going to thr this randomly let's do someone in the corner because I don't think you guys have gotten any but it's very funny watching people catching question that is fine so the question was what if we had U A plus equals 1 on a different line not in the return and then we return a so that is the same as example one actually when we're changing um the object a and we're returning just an L value a so that means we have named return value optimization good question okay example 10 so we have two more example sorry three more examples what we have here is volatile so I think Ben Dean did a talk about this earlier today which I may or may not have missed but volatile essentially tells the compiler that the value of the variable may change at any time without any action being taken by the code the compiler finds nearby so it's basically saying hey compile ER please don't optimize my code and if we had volatile in front of the parameters in the move and copy Constructor and if we had an example like this where we have my object volatile a do we have return value optimization please raise your hand if you think there is and keep it lowered if not okay we have a few hands raised so there is no return value optimization here and that's because we're telling the compiler don't optimize it right we're telling it so I will throw a random stress ball let's do this corner not hitting the projector uh yeah I'll try oop thank you oh the same person got it no good cool what if we remove the volatile so remember we still have the volatile in the parameter so we have my object volatile reference my object so the move and copy Constructor still have it but we have removed it from our example please raise your hand if you think there is return value optimization okay so even though our underlying code did have volatile because we don't have volatile here we're actually fine the optimization is still applied so this kind of I think you were first from my perspective so and I will also give one to the person at the back cuz you guys were very similar time wise no one got hurt during this talk at all okay we have return value optimization here and this is nice because even if you have underlying libraries that you call into that use volatile and depending on how they use it actually you might still be able to get return value optimization if you do the right thing example 11 so this is covering structured bindings so we have a wonderful little stood pair a quick question the volatile so the question was in the volatile case what happens to unnamed return value optimization we'll get to that actually at the end so I'll keep all questions at the end really good question okay and also remind me about it in case I forget okay over here in example 11 we have a St pair that's made up of my object three and then another my object 3 and we return it and the return value is then assigned to A and B so using a structured binding and finally we return a so there is return value optimization in the first part of this when return to my object pair returns its value but the question is is a return value optimization when we return a in example 11 please raise your hand if you think there is return value optimization and keep it lowered if you think there isn't okay we have a few hands raised there is no return value optimization here so structured bindings just means no rbo how about clang actually let's we can try this at the end and see what happens but I believe clang does the same thing but we can yeah g will throw this at [Music] someone well I tried so what we could do here to make this piece of code better is we could make two separate functions return A and B respectively and then we just get our normal return value optimization okay this is the last example hopefully I'm doing okay with time but this is a very fun example and I'm going to actually throw three holes press balls for this because this one tripped me up when I saw it the first time so what we have here is we have my object a that's being initialized or constructed and then we return a but a is in parentheses so this means it's no longer a vanilla L value or PR value do we have return value optimization please raise your hand if you think there is return value optimization and keep it lowered if you think there isn't okay we have barely 1/4 not even 1/10th of the hands of the hands raised so there is return value optimization here I'm going to throw three stress balls at the first three people I saw and okay you're really tricky to throw this too yes I won't do that yep cool so this is okay I will throw one more oh my God this is really tricky that was the camera thank you all right so those are all the examples but quick warning from what we just saw if you are writing a copy or move Constructor never make the Constructor do anything else other than a copy or move and why is that for a stress B yeah optimize the way were you going to say the same thing as well okay two stress balls it is one for you you and one for you so yeah the constructors can get a lied don't put anything important in there so we're going back to the standard and don't worry if you can't read this I'm going to zoom in what we have here is just the conditions for when return value optimization is applied so it does say when the expression is the name of a nonvolatile object so we have seen this example before with automatic storage duration and just we've not really seen this explicitly but if you have something that doesn't have tread local static or extern and there's essentially memory allocated at the beginning of that parenthesis so the closing block and the allocated at the end that just means it has automatic storage duration so it's a little trivial but good to know other than a function parameter so we did see the case where we have a function parameter and this means we didn't have return value optimization or a variable introduced by the exception Declaration of a Handler so we did see an example of this when we had a variable introduced by the exception declaration when the return type is the same so we do need the types to match and we saw this example as well ignoring CV qualification remember the const example we saw that when those conditions happen the standard says we have return value optimization so we have understood the C++ standard well a part of it but same thing so now it's time to go into your code base and change everything so that return value optimization is supported please raise your hand if you think we should be doing doing this yeah a lot of hands raised really appreciate it this is absolutely a great idea this is fine okay this is not actually a good idea it's actually a micro optimization because if you have maybe a flame graph that looks something like this where you have function one and function two and Function One calls two functions function 1 a and function 1 B so they're asynchronous functions if you try to optimize for return value optimization in function 1 a and even if that gets shorter function 1B is still going to you know run for however long it's running and so function two will still run at the same time so you're not optimizing your actual workflow so what you could do instead is use return value optimization when you see a bottleneck and of course you'll only know where a bottleneck is if you use profilers so I do have a few written up there but there are honestly a lot of profilers in the C++ ecosystem so pick your favorite one Go With It find your bottleneck the bottleneck may not be return value optimization it might be iio bound it might be anything but if it is return value optimization please optimize it and of course you can use return value optimization when you code and PR review so you might be wondering on a day-to-day basis how do I really know that I am using return value optimization correctly tooling is very important I think someone in the audience mentioned Clank tidy earlier but there are a number of tools to help you with return value optimization and knowing when to use it or how to use it so Kang and GCC have a pessim move so this tells you basically when using stood move in an incorrect way there's also warning c26 479 in Visual Studio code that tells you when you're using stood move incorrectly but my favorite one is W nvo so this is actually a relatively newer one and it's in GCC version 14 and above so it warns you if the compiler essentially does not allow the copy from a local variable to return value of a function so essentially it tells you when return value optimization could happen but it isn't happening and from all of the other warnings this one is my personal favorite but it doesn't actually catch some of the anti patterns we saw today so you still do need to be a little mindful of what you're doing and keep everything you saw today in mind so yeah we have seen what return value optimization is we've seen the types of of rbo the anti- patents preventing it from happening and how to use return value optimization for performance so that's it thank you for listening and I hope you enjoyed the talk I will take questions now as promised and I'm going to do something a bit fun maybe I don't know everything and if you're able to answer the question actually let's do this let someone ask a question and if someone else can answer the question I will give you a stress ball and if not we'll figure it out together how does that sound yeah okay any questions question there yeah yeah good question so the question was um essentially is that tooling for Kang in GCC to format your code so that return value optimization is applied right yeah yeah uh so the tools I found basically were these ones that I found the most useful I think we can get better though with the tooling we have so that it can automatically format things for us I do not know of any examples that do other than these really does anyone know if so I can stress ball stress ball at you okay no one knows as as well because probably there isn't anything out there yet so maybe this is inspiration for you to like go and write your own tool and then make it open so share it with the rest of us it's a good idea any other questions okay wait many okay question here so wondering about the yeah const exper and const eval so I actually wanted to have an example here but then I couldn't use it with my object because you need your con expert Destructor but um let's actually try this at the end together and find the answer for that and I does anyone know actually off the top of their head and I will give both of you stress BS by the way for questions so one for you so the question was with con exper and con steal do we have return value optimization does anyone know does anyone know yeah so the answer was because the compiler can compute it and knows it at compile time there's the optimization okay I'm going to throw this nicely okay any other questions okay question then right so the question was is a copy really that expensive right cuz yeah so for the question is how is is is a copy really expensive and yeah you're right so if you have a primitive type like integers doubles maybe it's not that expensive but then things add up at least that's what I've seen in production so when you have bigger objects or even things called multiple times those values do actually give you a uh performance hit that depends so the question was what's the performance speed up that you've seen in production so it depends on what you've optimized so you can actually get very lucky where you see things that people messed up because of course when you're coding out things maybe your focus isn't rbo maybe it is I need to get this feature delivered and so if if people haven't done things correctly and depending on how often that is done you can change things but the actual speed up is going to vary a lot based on what you change so I don't want to give you an exact figure because it is really going to vary but yeah yes so basically uh Brett mentioned that Brett mentioned that uh sometimes allocating memory is what really gives you that the issues and that's really expensive so something is there an STL yeah so when you have uh things where your move and copy Constructors are not there deleted I believe cortines sometimes have issues with this but yeah there are oh there on the library yet so yeah that's true I do not think so as to my knowledge but there's anyone disagree I actually believe 100% there isn't but in case anyone disputes me but yeah okay so no and I will also throw stress balls at people who bre is good that has too many stress balls okay and then one for you as [Music] well okay uh other questions question here yeah so the question was are there any cases where the optimization level is set to a certain amount but not the other that return value ization wouldn't be applied right uh so it depends on the compiler for example with o0 in GCC you would still have return value optimization applied you need to have that no Allied Constructor flag so it depends on your compiler in a way like msvc is different like we saw earlier right on that slide um but hopefully that answers it I will throw a stress ball at you nicely cool no head Miss but yeah with is there another question question yeah yeah so there was a comment in addition to what I said it also depends on the standard that is true depending on what the standard says right is that c yeah that is true so yeah there is a distinction between C++ 17 onwards and before because of the whole yeah things we saw earlier but yeah that's a good point me throw this at you cool all right um more questions I see one there yes go for it oh that's very interesting gotcha so basically it was uh what was it it was clang tidy sorry no what was the clang tidy has the issue so yeah CL with context for Clank had an issue uh the CL yeah sorry the Clank compiler my brain is meshed but yeah uh the Clank compiler has an issue uh with context but the other compilers deal with it just fine and stress ball for you no yes no are you sure okay no yes okay other questions question yes yeah so the question was with the structured binding example does uh was it forwarding wait I didn't hear that sorry oh this perfect forwarding essentially solve it I believe it May I'm actually not sure does anyone know yep ah perfect forwarding is a move Constructor oh it's very interesting I didn't actually think of that good question right okay so it cost us to into our value so it'll actually move it yeah be now you want a ball okay I'll give two a few stress balls the structured bindings is just a reference to the in object yeah right that's true and yes I will give you your stress ball nicely and not hit the projector close close enough and I shall give you a stress ball as well for your comment okay you have too many cool okay any other questions I have 29 SEC session is over okay fine if you have any other questions feel free to come up I also have a few more stress balls if you want a stress ball feel free to just yeah but yeah thank you again [Applause]